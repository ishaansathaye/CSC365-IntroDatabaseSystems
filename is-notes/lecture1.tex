\documentclass[twoside]{article}
\setlength{\oddsidemargin}{0.25 in}
\setlength{\evensidemargin}{-0.25 in}
\setlength{\topmargin}{-0.6 in}
\setlength{\textwidth}{6.5 in}
\setlength{\textheight}{8.5 in}
\setlength{\headsep}{0.75 in}
\setlength{\parindent}{0 in}
\setlength{\parskip}{0.1 in}

%
% add packages if you need them here:
%

\usepackage{amsmath,amsfonts,graphicx}
\usepackage{algorithm,caption}
\usepackage[noend]{algpseudocode}
\usepackage{url}
\usepackage{qtree}
%
% the following macro is used to generate the header.
%
\newcommand{\notes}[4]{
   \pagestyle{myheadings}
   \thispagestyle{plain}
   \newpage
   \setcounter{page}{1}
   \noindent
   \begin{center}
   \framebox{
      \vbox{\vspace{2mm}
    \hbox to 6.28in { {\bf CSC 365-07: Introduction to Database Systems
		\hfill Spring 2023} }
       \vspace{4mm}
       \hbox to 6.28in { {\Large \hfill Lecture 1:  Database and DBMS \hfill} }
       \vspace{2mm}
       \hbox to 6.28in { {\it Instructor: Alex Dekhtyar \hfill Ishaan Sathaye} }
      \vspace{2mm}}
   }
   \end{center}
}

% use these for theorems, lemmas, proofs, etc.
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newenvironment{proof}{{\bf Proof:}}{\hfill\rule{2mm}{2mm}}

\begin{document}
\notes




\section*{Introduction}
Definition of a database and DBMS in Professor Notes.

\newpage
\hfill \break
\framebox{
    \vbox{\vspace{2mm}
    \hbox to 6.28in { {\bf CSC 365-07: Introduction to Database Systems
    \hfill Spring 2023} }
    \vspace{4mm}
    \hbox to 6.28in { {\Large \hfill Lecture 2:  Relational Data Model \hfill} }
    \vspace{2mm}
    \hbox to 6.28in { {\it Instructor: Alex Dekhtyar \hfill Ishaan Sathaye} }
    \vspace{2mm}}
}

\section*{Relational Data Model}
\begin{definition}
    Relational data model is an approach to organizing collections of data
\end{definition}

\begin{itemize}
    \item Relation
    \begin{itemize}
        \item Relational Table $\longrightarrow$ \textbf{Name + Schema}
        \begin{itemize}
            \item Schema: List of attribute name + attribute type pairs
        \end{itemize}
    \end{itemize}
    \item Relational Database $\longrightarrow$ \textbf{Collection of Relations 
    tables}
    \item \textbf{Table Instance}: set of records with instantiated values of 
    the attributes
    \begin{itemize}
        \item Finite
        \item Records, rows, tuples
    \end{itemize}
\end{itemize}

One unit of data is called a \textbf{datum}.

Object, entity, event: description of one object, entity, event
\begin{itemize}
    \item \textbf{Records} consist of attributes or fields (rows in the 
    table).
    \item \textbf{Attributes} is a named container for a value of a specific type.
\end{itemize}

\subsection*{Database Table Constraint}
\begin{definition}
    Limitations of table instances
\end{definition}
\begin{itemize}
    \item \textbf{Candidate Key}: set or lists of attributes that uniquely
    define a record in a table, \textbf{minimal such set of attributes},
    made up of multiple attributes sometimes.
    \begin{itemize}
        \item \textbf{Every attribute is necessary.}
    \end{itemize}
\end{itemize}

\section*{Examples}
\subsection*{CSC 365 Example}

Course Object:
\begin{itemize}
    \item Prefix: CSC $\longrightarrow$ \textbf{String}
    \item Course \#: 365 $\longrightarrow$ \textbf{Integer}
    \item Name: Introduction to Database Systems $\longrightarrow$ \textbf{String}
    \item Description: Basic Principles, ... $\longrightarrow$ \textbf{String}
    \item Units: 4 $\longrightarrow$ \textbf{Integer}
\end{itemize}
Department Object:
\begin{itemize}
    \item Name: Computer Science and Software Engineering
    \item Abbreviation: CSSE
    \item Building: 14
    \item Room: 245
    \item College: CENG
\end{itemize}

Stringing these objects together based on relationship would 
make a \textbf{network model}.

\subsection*{Schema Example}
\begin{verbatim}
    Course(Prefix String, Course# Integer, Name String, Description
    String, Units Integer)
\end{verbatim}

\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        Prefix & Course\# & Name & Description & Units \\
        \hline
        CSC & 365 & Introduction to Database Systems & Basic Principles, ... & 4 \\
        \hline
        CSC & 357 & Systems Programming & ... & 4 \\
        \hline
    \end{tabular}
\end{table}

\begin{verbatim}
    Department(Name, College, Building, Room): Department would also have a table as well.
\end{verbatim}

\newpage
\hfill \break 
\framebox{
    \vbox{\vspace{2mm}
    \hbox to 6.28in { {\bf CSC 365-07: Introduction to Database Systems
    \hfill Spring 2023} }
    \vspace{4mm}
    \hbox to 6.28in { {\Large \hfill Lecture 3:  RDM Cont. \hfill} }
    \vspace{2mm}
    \hbox to 6.28in { {\it Instructor: Alex Dekhtyar \hfill Ishaan Sathaye} }
    \vspace{2mm}}
}

\section*{Relational Data Model}

What makes a record unique?
\begin{itemize}
    \item \textbf{Superkey}: any set of attributes that uniquely defines a 
    record in a table
    \item \textbf{Primary Key}: candidate key chosen by you
\end{itemize}

\newpage
\hfill \break 
\framebox{
    \vbox{\vspace{2mm}
    \hbox to 6.28in { {\bf CSC 365-07: Introduction to Database Systems
    \hfill Spring 2023} }
    \vspace{4mm}
    \hbox to 6.28in { {\Large \hfill Lecture 4: SQL DDL and DML \hfill} }
    \vspace{2mm}
    \hbox to 6.28in { {\it Instructor: Alex Dekhtyar \hfill Ishaan Sathaye} }
    }
}

\section*{MySQL Access}
\begin{enumerate}
    \item Server Address = host: \textbf{mysql.labthreesixfive.com}
    \item Port: 3306
    \item username
    \item password
\end{enumerate}

MySQL Database
\begin{itemize}
    \item Namespace
    \item Collection of Tables
    \item Set of Permissions
\end{itemize}

\section*{Case Sensitivity}
\subsection*{Case Sensitive}
\begin{itemize}
    \item Table Names
    \item Database Names
\end{itemize}
\subsection*{Not Case Sensitive}
\begin{itemize}
    \item Attribute Names
    \item SQL Keywords
\end{itemize}

\section*{Types}
\begin{itemize}
    \item \textbf{Numeric Types}
    \begin{itemize}
        \item \textbf{Integer Types}
        \begin{itemize}
            \item TINYINT
            \item SMALLINT
            \item MEDIUMINT
            \item \textbf{INT}
            \item BIGINT
        \end{itemize}
        \item \textbf{Floating Point Types}
        \begin{itemize}
            \item \textbf{FLOAT}
            \item \textbf{DOUBLE(P, D)}
            \item \textbf{DECIMAL}
        \end{itemize}
    \end{itemize}
    \item \textbf{String Types}
    \begin{itemize}
        \item \textbf{Character Types}
        \begin{itemize}
            \item \textbf{CHAR(N)} $\longrightarrow$ \textbf{Fixed Length}
            \item \textbf{VARCHAR(N)} $\longrightarrow$ \textbf{Variable Length}
            \item TINYTEXT
            \item \textbf{TEXT} $\longrightarrow$ for storing large amounts of 
            text
            \item MEDIUMTEXT
            \item LONGTEXT
        \end{itemize}
    \end{itemize}
    \item \textbf{Date and Time Types}
    \begin{itemize}
        \item \textbf{Date Types}
        \begin{itemize}
            \item DATE
            \item DATETIME
            \item TIMESTAMP
            \item TIME
            \item YEAR
        \end{itemize}
    \end{itemize}
\end{itemize}

\section*{Data Definition Language (DDL)}

\textbf{Commands from DDL act upon the schema}
\begin{itemize}
    \item CREATE TABLE
    \item DROP TABLE
    \item ALTER TABLE
\end{itemize}

\subsection*{Define a Relational Table}
Aspects needed to define a table:
\begin{itemize}
    \item Table Name
    \item Attributes: Name + Type
    \item Constraints
\end{itemize}

\begin{verbatim}
    CREATE TABLE <table_name> (
        <attribute_name> <sql_type> [<single_line_constraints>],
        ...,
        <attribute_name> <sql_type> [<single_line_constraints>] [,
        <constraints>[,
        <constraints>]
    ]);
\end{verbatim}

\section*{Data Manipulation Language (DML)}

\textbf{Commands from DML act upon the instance.}
\begin{itemize}
    \item INSERT
    \item DELETE
    \item UPDATE
\end{itemize}

\subsection*{Inserting Data}
\begin{verbatim}
    INSERT INTO <table_name>(<attribute_name>, ...)
        VALUES (<value>, ...);
\end{verbatim}
Supply values in order of attribute declarations in CREATE TABLE statement.
Can omit the attribute names if values supplied are in the same order. If need 
to omit
a value then omit that attribute name as well.

\section*{More on Constraints}
\begin{itemize}
    \item \textbf{[NOT] NULL} - attribute cannot be null
    \item \textbf{UNIQUE}
    \item \textbf{PRIMARY KEY}
    \item \textbf{FOREIGN KEY}
    \item \textbf{DEFAULT $<$exp$>$} - default value for attribute
    \item \textbf{AUTO\textunderscore INCREMENT} - means that the attribute is 
    an integer and is automatically incremented
\end{itemize}

\section*{Lab 2}
MySQL Server
\begin{itemize}
    \item LabThreeSixFive.com
    \item mysql command line client
    \item IDE (DatGrip)
    \item mysql connectivity from Python
\end{itemize}

Lab 2 uses Create Table, Drop Table, and Insert.

\section*{Code from Lab}
\begin{verbatim}
show tables

CREATE TABLE Departments (
    
    DeptId INT PRIMARY KEY, 
    Abbr VARCHAR(20) UNIQUE, -- UNIQUE makes candidate key
    Name VARCHAR(128) UNIQUE,
    College CHAR(10),
    Building INT,
    Room CHAR(6),
    -- set multiple candidate keys at the bottom
    UNIQUE(Building, Room),
    -- foreign key always a separate line statement:
    -- FOREIGN KEY(College) REFERENCES colleges(abbr)
    
);

describe colleges;
SELECT * FROM colleges;

show CREATE TABLE colleges;

show CREATE TABLE Departments;

INSERT INTO Departments 
    VALUES(1, 'CSSE', 'Computer Science and Software Engineering', 'CENG', 14, '245');
    
INSERT INTO Departments(DeptId, Abbr, Name, College, Building, Room)
    VALUES(1, 'CSSE', 'Computer Science and Software Engineering', 'CENG', 14, '245');

\end{verbatim}

\newpage
\hfill \break 
\framebox{
    \vbox{\vspace{2mm}
    \hbox to 6.28in { {\bf CSC 365-07: Introduction to Database Systems
    \hfill Spring 2023} }
    \vspace{4mm}
    \hbox to 6.28in { {\Large \hfill Lecture 5: DDL and DML Continued \hfill} }
    \vspace{2mm}
    \hbox to 6.28in { {\it Instructor: Alex Dekhtyar \hfill Ishaan Sathaye} }
    }
}

\section*{DML}
\subsection*{Updating Data}
\begin{verbatim}
    UPDATE <table_name>
        SET <attribute_name> = <value>
        WHERE <condition>;
\end{verbatim}

\subsubsection*{Example}
\begin{verbatim}
    UPDATE colleges
        SET abbr = 'COSAM'
        WHERE abbr = 'COASM'
\end{verbatim}

WHERE clause is a filter that determines which rows are updated.

\subsection*{Deleting Data}
\begin{verbatim}
    DELETE FROM <table_name> -- just this is a valid command to delete all rows
        WHERE <condition>;
\end{verbatim}

\section*{DDL}
\subsection*{Altering Tables}
\begin{verbatim}
    ALTER TABLE <table_name>
        <Command> <parameters>;
\end{verbatim}
\subsubsection*{Commands}
\begin{itemize}
    \item ADD - add a column/attribute/key
    \item DROP
    \item MODIFY
    \item RENAME
\end{itemize}
\subsubsection*{Parameters}
\begin{itemize}
    \item COLUMN
    \item CONSTRAINT
    \item FOREIGN KEY
    \item PRIMARY KEY
    \item UNIQUE
\end{itemize}

Adding an attribute, dropping/adding a constraint, renaming a table, disable/enabling
keys, and modifying attributes examples are in this professor notes: \url{4-SQLDDLDML.pdf}

\newpage
\hfill \break 
\framebox{
    \vbox{\vspace{2mm}
    \hbox to 6.28in { {\bf CSC 365-07: Introduction to Database Systems
    \hfill Spring 2023} }
    \vspace{4mm}
    \hbox to 6.28in { {\Large \hfill Lecture 6: DML/DDL Cont., WHERE Clause., 
    and MySQL Conn. \hfill} }
    \vspace{2mm}
    \hbox to 6.28in { {\it Instructor: Alex Dekhtyar \hfill Ishaan Sathaye} }
    }
}

\section*{Announcements}
\subsection*{Running Scripts for Lab 2}
Can run from command line using mysql command or using mysql client. For 
running using
mysql command need to specify the database if not using default database.
\begin{verbatim}
    source script.sql
\end{verbatim}

\section*{DML/DDL}

\textbf{Data Manipulation works on instance and Data Definition works on schema.}

\subsection*{Altering a Table}
Modifying the schema. ALTER examples in class.

For CREATE TABLE, you can name constraints: 
\begin{verbatim}
    CREATE TABLE Example (
        Id int PRIMARY KEY,
        X INT,
        Y INT,
        CONSTRAINT Point UNIQUE (X, Y)
    );
\end{verbatim}

\subsection*{Updating and Deleting from Table: WHERE Clause}

Ex. Deleting in Table
\begin{verbatim}
    DELETE FROM test02
        WHERE b > c
\end{verbatim}
This deletes rows where b is greater than c.

Ex. Deleting with Scope
\begin{verbatim}
    DELETE FROM test02
        FOR EACH ROW in test01
        DO 
            DELETE FROM test02 -- delete(row, condition)
            WHERE b > c
\end{verbatim}

\subsubsection*{SQL Boolean Expressions}
\begin{itemize}
    \item 0, 1
    \item Builtin: IN(...) $\longrightarrow$ returns bool
    \item $<Expression>$ $<op1>$ $<op2>$ // can also use IN or LIKE
    \item $<Expression>$ AND $<Expression>$
    \item $<Expression>$ OR $<Expression>$
    \item NOT $<Expression>$
\end{itemize}


\section*{MySQL Connectivity}
Breifly went over the Python examples on Course webpage that connect to 
MySQL server.

\newpage
\hfill \break 
\framebox{
    \vbox{\vspace{2mm}
    \hbox to 6.28in { {\bf CSC 365-07: Introduction to Database Systems
    \hfill Spring 2023} }
    \vspace{4mm}
    \hbox to 6.28in { {\Large \hfill Lecture 7: Python Connectivity and 
    Relational Algebra \hfill} }
    \vspace{2mm}
    \hbox to 6.28in { {\it Instructor: Alex Dekhtyar \hfill Ishaan Sathaye} }
    }
}

\section*{Python MySQL Connectivity}
Relational Database is sitting on a server. It is listening
for connections, and our program is a client that connects
to the server via the port. Essentially, there is a pipe and a
exchange of messages that is happening. Generates a connection object
that stores info about how to properly access the database.

\subsection*{Package}
\begin{verbatim}
    import mysql.connector
\end{verbatim}

\subsection*{Connection}
5 Things Needed: Host, Port, Username, Password, Database (sometimes not 
necessarily)

These get passed to mysql.connector.connect() function. This returns a 
connection object.
is\textunderscore connected() returns a cursor object.

Cursor object that is returned from the connection object. Cursor object is 
used to execute queries.


\section*{Relational Algebra}
Relational $\longrightarrow$ Database Model $\longrightarrow$ Relational Model.
Algebra: set of elements \& operations on elements

Relational Algebra is operations on relational tables.

Boolean Algebra introduces operations on truth values
\begin{itemize}
    \item T, F
    \item \textasciitilde, $\wedge$, $\vee$, $\rightarrow$, $\leftrightarrow$
\end{itemize}

\subsection*{Notation}
Upper case letters like R, S, T, $R_1$, $S_7$, ... are relational table names.
Letters from first half of alphabet like A, B, C, ... are attributes names.
R($A_1$,..., $A_n$) are to represent schema. t, s, r $\in$ R are tuples. $a_1$, $a_2$, ...
are values. Ex. t = ($a_1$,..., $a_n$) and it could be referred to as t.$A_1$ = $a_1$.

\subsection*{Operations}
\subsubsection*{Binary}
\subsubsection*{Unary}
\begin{itemize}
    \item Selection $\sigma$ - filter rows
    \item Projection $\pi$ - filter columns
\end{itemize}

\subsection*{Selection Operation}
\begin{itemize}
    \item $\sigma_{<selection condition>}(R)$ - returns rows that satisfy condition
    \item Selection Condition denoted by $C$
    \item Ex. C = $A_2 = 'Riley' \wedge A_3 = 'Hicks'$
    \item \textbf{Formal Notation:} $\sigma_C(R)$ = $\{t \in R | t  satisfies C\}$
\end{itemize}

\subsection*{Projection Operation}
\begin{itemize}
    \item $\pi_{<attribute list>}(R)$ - returns columns that are in attribute list
    \item $F$ is the projection list which is a list of attributes
    \item Ex. F = $(B_1,..., B_m)$ where $B_i$ $\in$ $A_1,..., A_n$
    \item \textbf{Formal Notation:} $\pi_F(R)$ = $\{t' | \exists,  t \in R, s.t. 
    \forall B \in F, t'.B=t.B\}$
    \item \textbf{Projection squeezes out duplicates}
\end{itemize}

\newpage
\hfill \break 
\framebox{
    \vbox{\vspace{2mm}
    \hbox to 6.28in { {\bf CSC 365-07: Introduction to Database Systems
    \hfill Spring 2023} }
    \vspace{4mm}
    \hbox to 6.28in { {\Large \hfill Lecture 8: Relational Algebra \hfill} }
    \vspace{2mm}
    \hbox to 6.28in { {\it Instructor: Alex Dekhtyar \hfill Ishaan Sathaye} }
    }
}

\section*{Relational Algebra}
R, S,  T are relational tables and these are sets. Set Operations include
Union, Intersection, Difference, Symmetric Difference...

Example:

\begin{table}[!htb]
    \begin{minipage}{.5\linewidth}
      \caption{R}
      \centering
        \begin{tabular}{c|c|c}
            A & B & C \\
            \hline
            1 & 2 & a \\
            2 & 4 & b \\
            3 & 1 & d \\
            4 & 4 & d \\
            4 & 5 & a \\
        \end{tabular}
    \end{minipage}
    \begin{minipage}{.25\linewidth}
      \centering
        \caption{S}
        \begin{tabular}{c|c|c}
            B & D & E \\
            \hline
            2 & a & 1 \\
            3 & a & 2 \\
            7 & b & 3 \\
            5 & b & 1 \\
            1 & c & 2 \\
        \end{tabular}
    \end{minipage} 
\end{table}

\subsection*{Selection Review}
Duplicate Elimination: $\sigma_{A=4 \vee B=4}(R)$

\begin{table}[!htb]
    \centering
    \begin{tabular}{c|c|c}
        A & B & C \\
        \hline
        2 & 4 & b \\
        4 & 4 & d \\
        4 & 5 & a \\
    \end{tabular}
\end{table}

\subsection*{Projection Review}
$\bullet$ Subset and Columns: $\pi_{B,D}(R)$. The schema here is $R(B,D)$.

$\bullet$ Can make composition of operations: $\pi_{B,E}(\sigma_{D=b}(R))$ because 
an result of an operation is a relational table. Result:
\begin{table}[!htb]
    \centering
    \begin{tabular}{c|c}
        B & E \\
        \hline
        7 & 3 \\
        5 & 1 \\
    \end{tabular}
\end{table}

$\bullet$ Can also reorder columns: $\pi_{EBD}(R)$

$\bullet$ Duplicate Columns: $\pi_{ABA}(R)$. Issue with this is that there are 2
columns with the same name. Disambiguate by renaming: $\pi_{A_1BA_2}(R)$

$\bullet$ Can also introduce new columns: $\pi_{A,B,2\cdot A}(R)$

\subsection*{Cartesian Product}
$\bullet$ $R \times S$ is the cartesian product of R and S. Result is a table 
with all possible combinations of rows from R and S. 

$\bullet$ Notation: $R \times S$ = $\{(t,t`) | t \in R, t \in S\}$

Ex. $\sigma_{A<3}(R) \times \sigma_{B<3}(S)$
\begin{table}[!htb]
    \centering
    \begin{tabular}{c|c|c|c|c|c}
        A & B & C & B & D & E \\
        \hline
        1 & 2 & a & 2 & a & 1 \\
        1 & 2 & a & 3 & a & 2 \\
        1 & 2 & a & 5 & b & 1 \\
        2 & 4 & b & 2 & a & 1 \\
        2 & 4 & b & 3 & a & 2 \\
        2 & 4 & b & 5 & b & 1 \\
    \end{tabular}
\end{table}

\subsection*{Join}

\begin{table}[!htb]
    \begin{minipage}{.5\linewidth}
      \caption{R}
      \centering
        \begin{tabular}{c|c|c}
            Id & Customer & C \\
            \hline
            1 & 2 & a \\
            2 & 4 & b \\
            3 & 1 & d \\
            4 & 4 & d \\
            4 & 5 & a \\
        \end{tabular}
    \end{minipage}
    \begin{minipage}{.25\linewidth}
      \centering
        \caption{S}
        \begin{tabular}{c|c|c}
            Id & Name & E \\
            \hline
            2 & a & 1 \\
            3 & a & 2 \\
            7 & b & 3 \\
            5 & b & 1 \\
            1 & c & 2 \\
        \end{tabular}
    \end{minipage} 
\end{table}

$\bullet$ Who purchased Receipt 3 $\longrightarrow$ Find a person with Id 1: $
\pi_{Name}(\pi_{R.Cust=S.Id}(\sigma_{Id=3}(R))\times S)$

$\bullet$ Notation: $R \bowtie_{C} S = \sigma_{R.x operation S.Y}(R \times S)$

\newpage
\hfill \break
\framebox{
    \vbox{\vspace{2mm}
    \hbox to 6.28in { {\bf CSC 365-07: Introduction to Database Systems
    \hfill Spring 2023} }
    \vspace{4mm}
    \hbox to 6.28in { {\Large \hfill Lecture 9: Joins \hfill} }
    \vspace{2mm}
    \hbox to 6.28in { {\it Instructor: Alex Dekhtyar \hfill Ishaan Sathaye} }
    \vspace{2mm}}
}

\section*{Announcements}
$\bullet$ Double-sided cheat sheet allowed for Midterm.
$\bullet$ Homework assigned on Thursday as prep for Midterm.

\section*{Example}

\begin{table}[!htb]
    \begin{minipage}{.5\linewidth}
      \caption{T}
      \centering
        \begin{tabular}{c|c|c|c}
            Id & Name & Course & Grade \\
            \hline
            1 & Joe & CSC 365 & A \\
            2 & Mary & CSC 365 & A \\
            3 & Lisa & CSC 101 & B \\
            4 & Luis & STAT 301 & C \\
            5 & Steve & STAT 301 & A \\
            1 & Joe & CSC 357 & B \\
            2 & Mary & CSC 357 & C \\
        \end{tabular}
    \end{minipage}
    \begin{minipage}{.25\linewidth}
      \centering
        \caption{C}
        \begin{tabular}{c|c}
            CourseId & Instructor \\
            \hline
            CSC 357 & Nico \\
            CSC 365 & Migler \\
            STAT 301 & Bodwin \\
            CSC 101 & Rivera \\
            STAT 302 & Frame \\
        \end{tabular}
    \end{minipage} 
\end{table}

Transcript Table T has primary key $(Id, Course)$ and foreign key $(Course)$ 
referencing Course Table C.

$\bullet$ \textbf{Find all Joe's instructors.}
\begin{gather*}
    \sigma_{Name=Joe}(T) \\
    \pi_{Course}(\sigma_{Name=Joe}(T)) \\
    C \times \pi_{Course}(\sigma_{Name=Joe}(T)) \\
    \sigma_{C.CourseNo=T.Course}(C \times \pi_{Course}(\sigma_{Name=Joe}(T))) \\
    \pi_{Instructor}(\sigma_{C.CourseNo=T.Course}(C 
    \times \pi_{Course}(\sigma_{Name=Joe}(T)))) \\
\end{gather*}

Cartesian Product in line 3 makes table with Course No., Instructor, and Course
combination for Joe. So it would be every combination with Course and CourseNo.:
\begin{table}[H]
    \centering
    \begin{tabular}{c|c|c|c}
        C.CourseNo & C.Instructor & T.Course \\
        \hline
        CSC 357 & Nico & CSC 365 \\
        CSC 365 & Migler & CSC 365 \\
        ... & ... & ... \\
        CSC 357 & Nico & CSC 357 \\
        CSC 365 & Migler & CSC 357 \\
        ... & ... & ... \\
    \end{tabular}
\end{table}

In Line 4, we are selecting the rows where the CourseNo. in C is equal to the
Courses in T. 

$\bullet$ \textbf{For each course grade, report the instructor who assigned it.}
\begin{gather*}
    \pi_{T.Course, T.Grade, C.Instructor}(\sigma_{T.Course=C.CourseId}(T 
    \times C))
\end{gather*}
First, we are taking the Cartesian product which gives us 35 rows. Then we are
making the table smaller by only selecting the rows that are equal in Courses.

\section*{$\Theta-$Join}
\begin{gather*}
    R \bowtie_{\Theta} S = \sigma_{\Theta}(R \times S) \\
\end{gather*}
\begin{center}
    $\Theta$ - selection condition where each comparison uses attributes from 
    R and S
\end{center}

\section*{Equi-Join}
\begin{gather*}
    R \bowtie_{\Theta} S \\
\end{gather*}
\begin{center}
    $\Theta$ = (R.A = S.B) $\wedge$ (R.C = S.D) $\wedge$ (R.E = S.F) \\
\end{center}

\section*{Natural Join}
\begin{center}
    $R(A_1,...A_k, B_1,...B_k)$ \\
    $S(B_1,...B_k, C_1,...C_k)$ \\
\end{center}
\begin{gather*}
    R \bowtie S = \pi_{R.*, S.C_1,...S.C_k}(R \bowtie_{Condition} S)
\end{gather*}
\begin{center}
    Condition is where $R.B_1$ = $S.B_1$ $\wedge$ ... $\wedge$ $R.B_k$ = $S.B_k$.
\end{center}
Natural join looks at all \textbf{common attributes} of two relations and joins on
them, removing one set of common attributes from the final relation.

\section*{Semi-Join}
Special case of natural join where only attributes of one relation are kept.
Essentially, it is a projection on all elements of 1 relation.

Left Semi Join:
\begin{gather*}
    R \bowtie_{\Theta} S = \pi_{R.*}(R \bowtie_{\Theta} S) \\
\end{gather*}

Right Semi Join:
\begin{gather*}
    R \bowtie_{\Theta} S = \pi_{S.*}(R \bowtie_{\Theta} S) \\
\end{gather*}

Example:
\begin{gather*}
    (\sigma_{Name=Joe}(R) \bowtie C) \\
\end{gather*}

\newpage
\hfill \break
\framebox{
    \vbox{\vspace{2mm}
    \hbox to 6.28in { {\bf CSC 365-07: Introduction to Database Systems
    \hfill Spring 2023} }
    \vspace{4mm}
    \hbox to 6.28in { {\Large \hfill Lecture 10: RA Operations \hfill} }
    \vspace{2mm}
    \hbox to 6.28in { {\it Instructor: Alex Dekhtyar \hfill Ishaan Sathaye} }
    \vspace{2mm}}
}

\section*{Examples}
\begin{table}[!htb]
    \begin{minipage}{.26\linewidth}
      \caption{Patients (P)}
      \centering
        \begin{tabular}{c|c|c}
            Id & Name & DoB \\
            \hline
            1 & Mary & 1/1/2000 \\
            2 & Jack & 3/7/1982 \\
            3 & Amy & 4/12/1976 \\
            4 & Tom & 12/17/1995 \\
        \end{tabular}
    \end{minipage}
    \begin{minipage}{.4\linewidth}
      \centering
        \caption{Prescriptions (R)}
        \begin{tabular}{c|c|c|c}
            PId & MId & Date & Refills \\
            \hline
            1 & 1 & 3/30/23 & 2 \\
            1 & 3 & 12/20/22 & 12 \\
            2 & 4 & 3/15/23 & 0 \\
            3 & 5 & 3/15/23 & 7\\
            3 & 2 & 1/1/23 & 3 \\
        \end{tabular}
    \end{minipage} 
    \begin{minipage}{.3\linewidth}
        \centering
          \caption{Medications (M)}
          \begin{tabular}{c|c|c}
            Id & Name & Dosage \\
            \hline
            1 & Ibuprofen & 200 \\
            2 & Ibuprofen & 500 \\
            3 & Metformin & 100 \\
            4 & Aspirin & 10 \\
            5 & Romapril & 20 \\
          \end{tabular}
      \end{minipage} 
\end{table}

$\bullet$ \textbf{Find Ibuprofen dosages for each patient (Name, Dosage).}
\begin{gather*}
    R \bowtie_{R.MId=M.Id} \sigma_{Name=Ibuprofen}(M) \\
    P \bowtie_{P.Id=R.Id}(R \bowtie_{R.MId=M.Id} \sigma_{Name=Ibuprofen}(M)) \\
    \pi_{P.Name, Dosage}(P \bowtie_{P.Id=R.Id}(R \bowtie_{R.MId=M.Id} 
    \sigma_{Name=Ibuprofen}(M))) \\
\end{gather*}
First line we add the columns of M to R but only the Ibuprofen rows. At the same
only adding these columns to the rows in R which have the MIds match: 
\begin{table}[H]
    \centering
    \begin{tabular}{c|c|c|c|c|c|c}
        PId & MId & Date & Refills & Id & Name & Dosage \\
        \hline
        1 & 1 & 3/30/23 & 2 & 1 & Ibuprofen & 200 \\
        3 & 2 & 1/1/23 & 3 & 2 & Ibuprofen & 500 \\
    \end{tabular}
\end{table}
Finally, in the second line we join this new schema with P only 
referring to the Ids:
\begin{table}[H]
    \centering
    \begin{tabular}{c|c|c|c|c|c|c|c|c|c}
        Id & Name & DoB & PId & MId & Date & Refills & Id & Name & Dosage \\
        \hline
        1 & Mary & 1/1/2000 & 1 & 1 & 3/30/23 & 2 & 1 & Ibuprofen & 200 \\
        3 & Amy &  4/12/1976 & 3 & 2 & 1/1/23 & 3 & 2 & Ibuprofen & 500 \\
    \end{tabular}
\end{table}
Then we just use projection to get the needed columns:
\begin{table}[H]
    \centering
    \begin{tabular}{c|c}
        Name & Dosage \\
        \hline
        Mary & 200 \\
        Amy & 500 \\
    \end{tabular}
\end{table}

$\bullet$ \textbf{Find all patients who are older than Jack.}
\begin{gather*}
    \sigma_{DoB < 3/7/82}(P) \\
\end{gather*}
This above equation is \textbf{wrong} because you are searching through all 
rows of P.
\begin{gather*}
    P \bowtie_{DoB < DoB}(\sigma_{Name = Jack}(P)) \\
\end{gather*}
This above is called a \textbf{self-join} because you are joining a table with 
itself.
But you need to disambiguate so you need to use the renaming operator $\rho$.
\begin{gather*}
    P \bowtie_{P.DoB < J.DoB}\rho_J(\sigma_{Name = Jack}(P)) \\
    \pi_{P.*}(P \bowtie_{P.DoB < J.DoB}\rho_J(\sigma_{Name = Jack}(P))) \\
\end{gather*}
right another way using left semi join.

\section*{Renaming Operator $\rho$}
\begin{gather*}
    \rho_{x}(R) \\
    \rho_{(A_1\longrightarrow B_1, \dots)}(R) \\
    \rho_{x(A_1\longrightarrow B_1, \dots)}(R) \\
\end{gather*}
First line renames the table name to x. Second line renames the attributes to
the new names. This is useful for self-joins. Can also combine first 2 lines as
in the third line.

Once M and R are renamed then they are forgotten for the duration of the
operation.

\section*{Expression Trees}
Example: Ibuprofen Relational Tree

Begin writing relational tree from the bottom up. Start with the inner most
operation and work your way up. For the above example the selection would be the
inner most operation and the outer join would be the topmost operation.

There can be multiple ways to represent the relational tree, but some trees work
better as they generate less data.

\Tree[.{$\bowtie$} [.P [.Det \textit{the} ]
               [.N\1 [.N \textit{package} ]]]
          [.I\1 [.I \textsc{3sg.Pres} ]
                [.VP [.V\1 [.V \textit{is} ]
                           [.AP [.Deg \textit{really} ]
                                [.A\1 [.A \textit{simple} ]
                                      \qroof{\textit{to use}}.CP ]]]]]]

\newpage
\hfill \break
\framebox{
    \vbox{\vspace{2mm}
    \hbox to 6.28in { {\bf CSC 365-07: Introduction to Database Systems
    \hfill Spring 2023} }
    \vspace{4mm}
    \hbox to 6.28in { {\Large \hfill Lecture 11: Relational Algebra 
    Continued and SQL Select Statement \hfill} }
    \vspace{2mm}
    \hbox to 6.28in { {\it Instructor: Alex Dekhtyar \hfill Ishaan Sathaye} }
    \vspace{2mm}}
}

\section*{Sort: $\tau$}
$\tau_F$ where F is a list of attributes. Sorts the relation by the attributes.
$F = A, B, C$ which is a project list. Can also put operations on the
attributes. $F = Desc(A\;MOD\;B), B, Desc(C)$.

\subsection*{Example}
\begin{table}[H]
    \centering
    \begin{tabular}{c|c|c}
        A & B & C \\
        \hline
        1 & 2 & 3 \\
        4 & 5 & 6 \\
        7 & 8 & 9 \\
    \end{tabular}
\end{table}

\begin{gather*}
    \pi_{B}(\tau_{Desc(A)}(R)) \\
\end{gather*}
This above sorts the table by A in descending order and then projects the B
column. The result is:
\begin{table}[H]
    \centering
    \begin{tabular}{c}
        B \\
        \hline
        8 \\
        5 \\
        2 \\
    \end{tabular}
\end{table}

\section*{Set Operations}
$\bullet$ \textbf{Only apply these when R, S have the same schema.}

$\bullet$ \textbf{These are bag operations.}

\subsection*{Union: $\cup$}
All elements that are in either set.

Definition:
\begin{gather*}
    R \cup S = \{t | t \in R \vee t \in S\} \\
\end{gather*}

\subsection*{Set Difference: $-$}
All elements that are in R but not in S.

Definition:
\begin{gather*}
    R - S = \{t | t \in R \wedge t \notin S\} \\
\end{gather*}

\subsection*{Intersection: $\cap$}
All elements that are in both sets.

Definition:
\begin{gather*}
    R \cap S = \{t | t \in R \wedge t \in S\} \\
\end{gather*}

\subsection*{Example}
\begin{table}[!htb]
    \begin{minipage}{.5\linewidth}
      \caption{R}
      \centering
        \begin{tabular}{c|c}
            A & B \\
            \hline
            1 & 2 \\
            4 & 5 \\
            7 & 8 \\
        \end{tabular}
    \end{minipage}
    \begin{minipage}{.3\linewidth}
      \centering
        \caption{S}
        \begin{tabular}{c|c}
            A & B \\
            \hline
            1 & 2 \\
            7 & 8 \\
            5 & 11 \\
            6 & 3 \\
        \end{tabular}
    \end{minipage} 
\end{table}
\begin{table}[!htb]
    \begin{minipage}{.26\linewidth}
      \caption{$R \cup S$}
      \centering
        \begin{tabular}{c|c}
            A & B \\
            \hline
            1 & 2 \\
            4 & 5 \\
            7 & 8 \\
            5 & 11 \\
            6 & 3 \\
        \end{tabular}
    \end{minipage}
    \begin{minipage}{.4\linewidth}
      \centering
        \caption{$R - S$}
        \begin{tabular}{c|c}
            A & B \\
            \hline
            4 & 5 \\
        \end{tabular}
    \end{minipage} 
    \begin{minipage}{.3\linewidth}
        \centering
          \caption{$R \cap S$}
          \begin{tabular}{c|c}
                A & B \\
                \hline
                1 & 2 \\
                7 & 8 \\
          \end{tabular}
      \end{minipage} 
\end{table}

\section*{Duplicate Elimination: $\delta$}
Removes duplicate tuples from a relation. Definition: $\delta(R)$. 
This is a set representation of bag R.

\textbf{This operation allows us to go between bag and set representations.}
Example: $R \cap S$ would allow duplicates, but $\delta(R - S)$ would not.

\section*{SQL Select Statement}
\textit{Technical Debt: }Grouping and Outer Joins

\begin{verbatim}
    SELECT <select-list>
    FROM <table1>, <table2>, ...
    WHERE <condition>
    ORDER BY <sort-list>
\end{verbatim}

$\bullet$ FROM gets evaluated first. Here cartesian products and renaming 
operations are done. 

$\bullet$ WHERE gets evaluated second. Responsible for the conversion between
cartesian product to joins.

$\bullet$ ORDER BY gets evaluated next. Responsible for sorting.

$\bullet$ SELECT gets evaluated last. Responsible for projection and some
renaming to be done.

\subsection*{Patterns:}
$\sigma_C(R)$ translates to the following SQL statement:
\begin{verbatim}
    SELECT *
    FROM R
    WHERE C
\end{verbatim}

$\pi_F(R)$ translates to the following SQL statement:
\begin{verbatim}
    SELECT DISTINCT F --removes duplicates
    FROM R
\end{verbatim}

$\tau_F(R)$ translates to the following SQL statement:
\begin{verbatim}
    SELECT DISTINCT F
    FROM R
    ORDER BY F
\end{verbatim}

$R \times S$ translates to the following SQL statement:
\begin{verbatim}
    SELECT * -- start because there is no projection
    FROM R, S
\end{verbatim}


\end{document}
